{
  "version": "1.0",
  "exportedAt": "2025-01-19T00:00:00.000Z",
  "metadata": {
    "originalId": "replicated-onboarding-guide-2025",
    "createdFor": "Replicated Platform onboarding",
    "importedFrom": "Replicated Documentation",
    "version": "2025.01.19"
  },
  "walkthrough": {
    "title": "Replicated Platform Onboarding Guide",
    "description": "A comprehensive guide to onboard applications to the Replicated Platform. Learn to distribute Kubernetes applications with Embedded Cluster, KOTS, and Helm installations while integrating preflight checks, support bundles, and custom configurations.",
    "type": "quickstart",
    "status": "published",
    "estimatedDurationMinutes": 180,
    "tags": ["replicated", "onboarding", "kubernetes", "helm", "embedded-cluster", "kots", "distribution"],
    "metadata": {
      "createdFor": "Replicated Platform onboarding",
      "importedFrom": "Replicated Documentation",
      "version": "2025.01.19"
    }
  },
  "steps": [
    {
      "title": "Introduction to Replicated Platform",
      "contentFields": {
        "version": "v1",
        "introductionForAgent": "Welcome the user to the Replicated Platform onboarding process. Explain that Replicated helps software vendors distribute Kubernetes applications to enterprise customers with multiple installation methods. Set expectations that they'll be creating a complete production-ready application distribution system.",
        "contextForAgent": "Replicated Platform is a complete solution for distributing Kubernetes applications to enterprise customers. It supports multiple installation methods: Embedded Cluster (air-gapped Kubernetes clusters), KOTS (existing clusters), and Helm CLI installations. The platform includes customer management, license enforcement, support tooling, analytics, and automated air-gap bundle creation.",
        "contentForUser": "# Welcome to Replicated Platform! 🚀\n\nReplicated Platform helps software vendors distribute Kubernetes applications to enterprise customers with confidence. Here's what makes Replicated special:\n\n## Multiple Installation Methods\n- **Embedded Cluster**: Deploy complete Kubernetes clusters to customer environments\n- **KOTS**: Install into existing Kubernetes clusters with management UI\n- **Helm**: Native Helm CLI installations for developer workflows\n\n## Enterprise Features\n- **Air-gap support** for secure, offline environments\n- **License management** and customer entitlements\n- **Preflight checks** to validate customer environments\n- **Support bundles** for troubleshooting\n- **Analytics and insights** from customer deployments\n\n## What You'll Accomplish\nBy the end of this walkthrough, you'll have:\n✅ **Created** a Replicated application with proper configuration\n✅ **Packaged** your Helm chart with the Replicated SDK\n✅ **Configured** multiple installation methods\n✅ **Set up** customer-facing configuration screens\n✅ **Added** preflight checks and support bundle collection\n✅ **Tested** your application in development environments\n\nThis process typically takes 3 hours and will result in a production-ready application distribution system.",
        "operationsForAgent": "1. Introduce Replicated Platform and its core value propositions\n2. Explain the three main installation methods (Embedded Cluster, KOTS, Helm)\n3. Set expectations for the onboarding process duration (~3 hours)\n4. Outline what they'll accomplish by the end\n5. Check if they have any initial questions about Replicated's capabilities\n6. Ask if they're ready to begin the onboarding process"
      },
      "displayOrder": 0,
      "nextStepReference": 1
    },
    {
      "title": "Prerequisites and Environment Setup",
      "contentFields": {
        "version": "v1",
        "introductionForAgent": "Guide the user through all prerequisites and setup requirements for Replicated onboarding. This includes account creation, CLI installation, environment preparation, and understanding system requirements for testing installations.",
        "contextForAgent": "Prerequisites include: Replicated Vendor Portal account, Replicated CLI installation, VM for Embedded Cluster testing (Linux with systemd, 2GB RAM, 2 CPU cores), optional Kubernetes cluster for KOTS testing, Helm chart ready for packaging, and completion of basic Replicated quick start to understand workflows.",
        "contentForUser": "# Prerequisites and Setup\n\nBefore we begin onboarding, let's ensure you have everything needed for a smooth experience.\n\n## Required Accounts and Tools\n\n### Vendor Portal Account\n- Access to https://vendor.replicated.com\n- **Sign up process**: Email or Google authentication\n- **Account activation**: Email verification required\n- **Team creation**: Company name becomes team name\n- **Important**: Use temporary application name initially (e.g., \"My-Application-Demo\")\n\n### Development Environment\n- **Replicated CLI**: Command-line tool for managing applications\n- **Docker**: Container runtime (must be running)\n- **Helm CLI**: Kubernetes package manager\n- **kubectl**: Kubernetes command-line tool (for existing cluster testing)\n- **Code Editor**: VS Code, IntelliJ, etc.\n\n## Testing Environment Requirements\n\n### For Embedded Cluster Testing (Required)\n- **VM with Linux OS** (Ubuntu 20.04+, RHEL 8+, etc.)\n- **x86-64 architecture** with systemd\n- **Minimum Resources**: 2GB RAM, 2 CPU cores\n- **Storage**: 40GB+ available space (<80% full)\n- **Disk Performance**: Max P99 write latency 10ms (for etcd)\n- **Network Access**: replicated.app and proxy.replicated.com\n- **SSH Access**: With sudo privileges\n\n### For KOTS Testing (Optional)\n- **Kubernetes cluster** with kubectl access\n- **Cluster Admin**: Permissions for installing applications\n- **Options**: GKE, EKS, AKS, minikube, kind, etc.\n\n## Your Application Requirements\n- **Helm Chart**: Working, tested chart ready for packaging\n- **Container Images**: In accessible registry with proper credentials\n- **Configuration Knowledge**: Understanding of your app's setup needs\n- **Testing**: Chart should install successfully with `helm install`",
        "operationsForAgent": "1. **Create Replicated Vendor Portal account if needed:**\n   - Go to https://vendor.replicated.com and select \"Sign up\"\n   - Enter email address or use Google authentication\n   - If using email: check for activation code, copy/paste it, click \"Activate\"\n   - On \"Create your team\" page: enter first name, last name, company name\n   - Click \"Continue\" to complete setup\n   - **Important**: Use temporary application name like \"My-Application-Demo\" or \"My-Application-Test\"\n   - Application names and slugs cannot be changed later\n   - Note: Company name becomes team name in Vendor Portal\n\n2. **Install Replicated CLI:**\n   - Guide them to: https://docs.replicated.com/reference/replicated-cli-installing\n   - **macOS**: `brew install replicatedhq/replicated/cli`\n   - **Linux**: `curl -s https://api.replicated.com/market/v1/echo/cli-latest | bash`\n   - **Windows**: Download from releases page\n   - Verify installation: `replicated version`\n\n3. **Set up local development environment:**\n   - Ensure they have Docker installed and running\n   - Verify Helm CLI is installed: `helm version`\n   - Check kubectl access if testing with existing clusters\n   - Confirm they have a code editor (VS Code, etc.)\n\n4. **Assess their current Helm chart status:**\n   - Do they have a working Helm chart?\n   - Are their container images in a registry they control?\n   - Have they tested the chart with `helm install`?\n   - Do they understand their chart's configuration requirements?\n\n5. **Verify testing environment access:**\n   - **Required**: Linux VM for Embedded Cluster testing\n     - Ubuntu 20.04+ or RHEL 8+ recommended\n     - At least 2GB RAM, 2 CPU cores, 40GB storage\n     - SSH access with sudo privileges\n   - **Optional**: Kubernetes cluster for KOTS testing\n     - Any cloud provider (GKE, EKS, AKS) or local (minikube, kind)\n     - kubectl access with cluster-admin permissions\n\n6. **Recommend prerequisite learning:**\n   - Complete basic Replicated Quick Start: https://docs.replicated.com/vendor/quick-start\n   - Review Helm chart best practices if needed\n   - Understand Kubernetes basics (pods, deployments, services)\n\n7. **Final readiness check:**\n   - Do they have 3+ hours available for the complete onboarding?\n   - Are they ready to create their official application (not test app)?\n   - Do they have necessary credentials for their image registry?\n   - Confirm they understand this will create production-ready distribution"
      },
      "displayOrder": 1,
      "nextStepReference": 2
    },
    {
      "title": "Task 1: Create An Application",
      "contentFields": {
        "version": "v1",
        "introductionForAgent": "Guide the user through creating their official Replicated application in the Vendor Portal. This will be the main application used for both internal development and customer-facing releases. Explain the importance of choosing a good application name since the slug cannot be changed later.",
        "contextForAgent": "Applications in Replicated have both a display name (changeable) and a slug (permanent). The slug is auto-generated from the name and must be unique across all Replicated applications. The slug is used in CLI commands and API calls. The REPLICATED_APP environment variable should be set to make CLI operations easier throughout onboarding.",
        "contentForUser": "# Task 1: Create An Application\n\nLet's start by creating your official Replicated application. This will be the central hub for managing all your releases, customer licenses, and distribution channels.\n\n## Application Naming\n- **Display Name**: Can be changed later (e.g., \"My Enterprise App\")\n- **Application Slug**: Auto-generated, **permanent** (e.g., `my-enterprise-app`)\n- Choose wisely - the slug cannot be changed later!\n\n## What We'll Create\n- Official Vendor Portal application for your team\n- Unique application identifier (slug)\n- Foundation for all future releases and customer management",
        "operationsForAgent": "1. Help them create the application:\n   **Option A: Using Replicated CLI**\n   ```bash\n   replicated app create \"Your App Name\"\n   ```\n   **Option B: Using Vendor Portal**\n   - Navigate to https://vendor.replicated.com\n   - Click \"Create New App\"\n   - Enter application name\n   - Click \"Create Application\"\n\n2. Note the generated application slug from the output/UI\n\n3. Set the REPLICATED_APP environment variable:\n   ```bash\n   export REPLICATED_APP=your-app-slug\n   ```\n   Recommend adding this to their shell profile (.bashrc, .zshrc, etc.)\n\n4. Verify the setup:\n   ```bash\n   replicated app ls\n   ```\n   Should show their new application\n\n5. Explain that this slug will be used throughout the CLI commands\n6. Confirm they can see the application in both CLI and Vendor Portal\n7. Ask if they want to proceed to connecting their image registry"
      },
      "displayOrder": 2,
      "nextStepReference": 3
    },
    {
      "title": "Task 2: Connect Your Image Registry",
      "contentFields": {
        "version": "v1",
        "introductionForAgent": "Guide the user through connecting their private image registry to Replicated. This enables the proxy registry feature, which allows customers to pull application images without exposing registry credentials. Support major registries like Docker Hub, AWS ECR, GCR, and Azure Container Registry.",
        "contextForAgent": "The Replicated proxy registry allows customers to pull private images through proxy.replicated.com without needing the vendor's registry credentials. Replicated supports major registries and handles authentication. This is essential for secure image distribution and air-gap installations.",
        "contentForUser": "# Task 2: Connect Your Image Registry\n\nConnect your private image registry to enable Replicated's proxy registry feature. This allows customers to access your application images securely without exposing your registry credentials.\n\n## Proxy Registry Benefits\n- **Security**: Customers never see your registry credentials\n- **Air-gap support**: Images included in offline installation bundles\n- **Access control**: Tied to customer licenses and entitlements\n- **Multiple registries**: Support for all major container registries\n\n## Supported Registries\n- Docker Hub\n- AWS Elastic Container Registry (ECR)\n- Google Container Registry (GCR)\n- Azure Container Registry (ACR)\n- Harbor, Quay.io, and others",
        "operationsForAgent": "1. Navigate to the Vendor Portal:\n   - Go to https://vendor.replicated.com\n   - Select their application\n   - Go to \"Registry Settings\" or \"Images\" section\n\n2. Click \"Add Registry\" or \"Connect Registry\"\n\n3. Help them choose their registry type and provide credentials:\n   **For Docker Hub:**\n   - Registry: Docker Hub\n   - Username: Their Docker Hub username\n   - Password/Token: Docker Hub access token (recommend creating one)\n   \n   **For AWS ECR:**\n   - Registry: AWS ECR\n   - Region: Their AWS region\n   - Access Key ID: AWS access key with ECR permissions\n   - Secret Access Key: Corresponding secret key\n   \n   **For Google GCR:**\n   - Registry: Google Container Registry\n   - Service Account JSON: JSON key file content\n   \n   **For Azure ACR:**\n   - Registry: Azure Container Registry\n   - Username: Service principal ID or admin username\n   - Password: Service principal password or admin password\n\n4. Test the connection by clicking \"Test\" or \"Validate\"\n\n5. Verify the registry appears in their connected registries list\n\n6. Explain that images will now be available through proxy.replicated.com\n\n7. Ask about their Helm chart - are they ready to package it with the Replicated SDK?"
      },
      "displayOrder": 3,
      "nextStepReference": 4
    },
    {
      "title": "Task 3: Add the Replicated SDK and Package Your Chart",
      "contentFields": {
        "version": "v1",
        "introductionForAgent": "Guide the user through adding the Replicated SDK as a dependency to their Helm chart and packaging it. The SDK provides in-cluster API access, telemetry, and insights. This is a crucial step that enables many Replicated features.",
        "contextForAgent": "The Replicated SDK is a lightweight Helm chart dependency that runs as a small service in the customer's cluster. It provides an in-cluster API for license validation, customer identification, and telemetry collection. It should only be declared in one chart if the application uses multiple charts, typically the primary/first chart installed.",
        "contentForUser": "# Task 3: Add the Replicated SDK and Package Your Chart\n\nThe Replicated SDK is a lightweight service that runs alongside your application to provide key Replicated functionality.\n\n## SDK Features\n- **In-cluster API**: License validation and customer identification\n- **Automatic telemetry**: Instance insights and operational data\n- **Customer analytics**: Usage patterns and deployment health\n- **Small footprint**: Minimal resource usage\n\n## Integration Process\n1. Add SDK as Helm chart dependency\n2. Package chart with dependencies\n3. Prepare for first release creation\n\n**Note**: If you have multiple Helm charts, add the SDK only to the chart that customers install first.",
        "operationsForAgent": "1. Navigate to their Helm chart directory:\n   ```bash\n   cd /path/to/your/helm/chart\n   ```\n\n2. Open their `Chart.yaml` file and add the Replicated SDK dependency:\n   ```yaml\n   # Chart.yaml\n   dependencies:\n   - name: replicated\n     repository: oci://registry.replicated.com/library\n     version: 1.5.1\n   ```\n   Note: Check https://github.com/replicatedhq/replicated-sdk/releases for the latest version\n\n3. If they have multiple charts, ask which chart customers install first - only add SDK there\n\n4. Update dependencies and package the chart:\n   ```bash\n   helm package -u .\n   ```\n   The `-u` flag updates dependencies before packaging\n\n5. Verify the packaged .tgz file was created:\n   ```bash\n   ls *.tgz\n   ```\n   Should see something like `your-app-1.0.0.tgz`\n\n6. If they see a \"401 Unauthorized\" error:\n   ```bash\n   helm registry logout registry.replicated.com\n   helm package -u .\n   ```\n\n7. For multiple charts, repeat the packaging process for each chart:\n   ```bash\n   helm package -u /path/to/chart2\n   helm package -u /path/to/chart3\n   ```\n\n8. Confirm all .tgz files are created and ready\n\n9. Explain that next we'll create the initial release with these packaged charts"
      },
      "displayOrder": 4,
      "nextStepReference": 5
    },
    {
      "title": "Task 4: Create the Initial Release with KOTS HelmChart and Embedded Cluster Config",
      "contentFields": {
        "version": "v1",
        "introductionForAgent": "Guide the user through creating their first Replicated release. This involves creating a manifests directory with the packaged Helm chart, KOTS HelmChart custom resource, and Embedded Cluster Config. This is complex and requires careful attention to image rewriting for the proxy registry.",
        "contextForAgent": "The first release requires: 1) Packaged Helm chart .tgz files, 2) KOTS HelmChart custom resource for each chart (configures proxy registry image rewriting), 3) Embedded Cluster Config with Kubernetes version. The HelmChart resource is complex and involves KOTS template functions for image rewriting. Allow 2-3 hours for this task.",
        "contentForUser": "# Task 4: Create the Initial Release\n\nNow we'll create your first Replicated release with the minimum files needed for Embedded Cluster and KOTS installations.\n\n## Required Release Files\n- **Helm Chart Archive(s)**: Your packaged .tgz files\n- **KOTS HelmChart Custom Resource**: Configures image access and values\n- **Embedded Cluster Config**: Specifies Kubernetes version and settings\n\n## What the HelmChart Custom Resource Does\n- **Image Rewriting**: Redirects images through Replicated proxy registry\n- **Image Pull Secrets**: Provides authentication for private images  \n- **Helm Values**: Maps configuration to your chart values\n- **Installation Control**: Manages deployment order and dependencies\n\n⚠️ **Time Estimate**: This task typically takes 2-3 hours due to the complexity of configuring image rewriting and KOTS template functions.",
        "operationsForAgent": "1. Create a manifests directory in their chart directory:\n   ```bash\n   mkdir manifests\n   cd manifests\n   ```\n\n2. Move the packaged chart(s) to manifests:\n   ```bash\n   mv ../your-app-*.tgz .\n   ```\n\n3. Create embedded-cluster.yaml with default config:\n   ```yaml\n   apiVersion: embeddedcluster.replicated.com/v1beta1\n   kind: Config\n   spec:\n     version: 2.1.3+k8s-1.30\n   ```\n\n4. Create KOTS HelmChart custom resource (this is complex):\n   \n   **Start with basic structure (helmchart.yaml):**\n   ```yaml\n   apiVersion: kots.io/v1beta2\n   kind: HelmChart\n   metadata:\n     name: your-app\n   spec:\n     chart:\n       name: your-app\n       chartVersion: \"1.0.0\"\n     weight: 1\n   ```\n\n5. **Configure image rewriting (this is the complex part):**\n   ```yaml\n   spec:\n     values:\n       image:\n         repository: '{{repl ImageRegistry \"your-registry.com/your-app\"}}{{repl ImageName \"your-registry.com/your-app\"}}'\n         tag: '{{repl ImageTag \"your-registry.com/your-app:v1.0.0\"}}'\n     optionalValues:\n     - when: '{{repl HasLocalRegistry}}'\n       recursiveMerge: false\n       values:\n         imagePullSecrets:\n         - name: '{{repl ImagePullSecretName}}'\n   ```\n\n6. **Help them identify their images:**\n   - Look in their Helm templates for image references\n   - Common locations: deployment.yaml, statefulset.yaml, daemonset.yaml\n   - Note the full image paths (registry/namespace/image:tag)\n\n7. **Walk through the HelmChart configuration workflow:**\n   - Follow: https://docs.replicated.com/vendor/helm-native-v2-using\n   - This is detailed and requires understanding their specific images\n   - May take 1-2 hours depending on complexity\n\n8. **Create the release:**\n   ```bash\n   replicated release create --yaml-dir . --promote Unstable\n   ```\n\n9. **Test installation:**\n   - Install on VM with Embedded Cluster\n   - Follow: https://docs.replicated.com/enterprise/installing-embedded\n   - Verify application deploys successfully\n\n10. Troubleshoot any issues with image access or deployment\n11. Celebrate the first successful installation!"
      },
      "displayOrder": 5,
      "nextStepReference": 6
    },
    {
      "title": "Task 5: Customize the KOTS Admin Console",
      "contentFields": {
        "version": "v1",
        "introductionForAgent": "Guide the user through customizing the KOTS Admin Console by configuring the Application custom resource. This adds branding (name and icon) and status informers to show application health on the dashboard. The icon should be base64 encoded.",
        "contextForAgent": "The KOTS Application custom resource customizes the Admin Console experience. The title and icon are shown in the Admin Console and Download Portal. Status informers use Kubernetes resource selectors to determine application health - typically deployments, statefulsets, or daemonsets. The icon must be base64 encoded image data.",
        "contentForUser": "# Task 5: Customize the KOTS Admin Console\n\nLet's customize the Admin Console experience for your users by adding your application's branding and health monitoring.\n\n## Admin Console Customization\n- **Application Title**: Friendly name shown to users\n- **Application Icon**: Brand logo displayed in UI (base64 encoded)\n- **Status Informers**: Monitor application health automatically\n\n## Status Informers\nThese help users understand if your application is running properly:\n- Monitor Deployments, StatefulSets, DaemonSets\n- Show \"Ready\", \"Degraded\", or \"Unavailable\" status\n- Provide quick health overview on dashboard",
        "operationsForAgent": "1. In the manifests directory, create kots-app.yaml:\n   ```yaml\n   apiVersion: kots.io/v1beta1\n   kind: Application\n   metadata:\n     name: your-app\n   spec:\n     title: Your Application Name\n     statusInformers:\n       - deployment/your-app-deployment\n   ```\n\n2. **Add application icon (optional but recommended):**\n   - Help them encode their logo to base64:\n     ```bash\n     base64 -i your-logo.png\n     ```\n   - Add to the spec:\n     ```yaml\n     spec:\n       title: Your Application Name\n       icon: iVBORw0KGgoAAAANSUhEUgAA...  # base64 encoded image\n       statusInformers:\n         - deployment/your-app-deployment\n     ```\n\n3. **Configure status informers based on their application:**\n   - Ask what Kubernetes resources they deploy\n   - Common patterns:\n     ```yaml\n     statusInformers:\n       - deployment/frontend\n       - deployment/backend\n       - statefulset/database\n     ```\n   - Or use labels:\n     ```yaml\n     statusInformers:\n       - 'app.kubernetes.io/name=your-app'\n     ```\n\n4. **Test the icon preview in Vendor Portal:**\n   - They can preview the icon before releasing\n   - Go to \"Edit release\" → \"Help\" pane → \"Application icon preview\"\n\n5. **Create and promote new release:**\n   ```bash\n   replicated release create --yaml-dir . --promote Unstable\n   ```\n\n6. **Test the changes:**\n   - Upgrade their Embedded Cluster installation\n   - Verify the title and icon appear in Admin Console\n   - Check that status shows application health correctly\n\n7. **Troubleshoot status informers if needed:**\n   - Verify resource names match exactly\n   - Check that resources are in the correct namespace\n   - Ensure resources have proper labels if using label selectors"
      },
      "displayOrder": 6,
      "nextStepReference": 7
    },
    {
      "title": "Task 6: Set Up the Admin Console Config Screen and Map to Helm Values",
      "contentFields": {
        "version": "v1",
        "introductionForAgent": "Guide the user through creating the KOTS Config custom resource to build a configuration screen for their users. This involves understanding their application's configuration needs and mapping user inputs to Helm values using KOTS template functions. This is complex and can take 2-3 hours.",
        "contextForAgent": "The KOTS Config custom resource creates user-facing configuration screens in the Admin Console. It supports various input types (text, boolean, select, etc.), conditional logic, validation, and groups. User inputs are mapped to Helm values using KOTS template functions like ConfigOption. This allows non-technical users to configure complex applications.",
        "contentForUser": "# Task 6: Set Up the Admin Console Config Screen\n\nCreate a user-friendly configuration screen where customers can customize your application settings without editing YAML files.\n\n## Config Screen Features\n- **Multiple Input Types**: Text fields, dropdowns, checkboxes, file uploads\n- **Conditional Logic**: Show/hide fields based on other selections\n- **Validation**: Ensure users provide valid configuration\n- **Grouping**: Organize related settings together\n- **Help Text**: Guide users with descriptions and examples\n\n## Integration with Helm\n- User selections automatically map to your Helm chart values\n- No manual YAML editing required for customers\n- Type-safe configuration with validation\n\n⚠️ **Time Estimate**: This task typically takes 2-3 hours depending on your application's configuration complexity.",
        "operationsForAgent": "1. **Understand their application's configuration needs:**\n   - What settings do users typically need to configure?\n   - Database connections, ingress settings, resource limits, features flags?\n   - Review their current Helm values.yaml for ideas\n\n2. **Create kots-config.yaml with basic structure:**\n   ```yaml\n   apiVersion: kots.io/v1beta1\n   kind: Config\n   metadata:\n     name: your-app\n   spec:\n     groups:\n       - name: basic_config\n         title: Basic Configuration\n         items:\n           - name: app_name\n             title: Application Name\n             type: text\n             default: \"My Application\"\n             help_text: \"The display name for your application\"\n   ```\n\n3. **Add more configuration fields based on their needs:**\n   ```yaml\n   - name: database_settings\n     title: Database Configuration\n     items:\n       - name: db_host\n         title: Database Host\n         type: text\n         default: \"postgres\"\n       - name: db_port\n         title: Database Port\n         type: text\n         default: \"5432\"\n       - name: enable_ssl\n         title: Enable SSL\n         type: bool\n         default: \"true\"\n   ```\n\n4. **Preview the config screen:**\n   - Create a release to see the config preview in Vendor Portal\n   - Go to \"Edit release\" → \"Help\" pane → \"Config preview\"\n\n5. **Map config values to Helm values in the HelmChart resource:**\n   ```yaml\n   # In helmchart.yaml\n   spec:\n     values:\n       app:\n         name: '{{repl ConfigOption \"app_name\"}}'\n       database:\n         host: '{{repl ConfigOption \"db_host\"}}'\n         port: '{{repl ConfigOption \"db_port\" | ParseInt}}'\n         ssl: '{{repl ConfigOption \"enable_ssl\" | ParseBool}}'\n   ```\n\n6. **Test the complete flow:**\n   - Create and promote new release\n   - Install/upgrade in test environment\n   - Verify config screen appears in Admin Console\n   - Test that changing values updates the application\n\n7. **Add more sophisticated config items as needed:**\n   - Conditional fields with `when` conditions\n   - Select dropdowns with options\n   - File uploads for certificates\n   - Validation rules\n\n8. **Iterate on the configuration:**\n   - Continue adding fields until all necessary configuration is covered\n   - Test each iteration in the development environment"
      },
      "displayOrder": 7,
      "nextStepReference": 8
    },
    {
      "title": "Task 7: Define Preflight Checks",
      "contentFields": {
        "version": "v1",
        "introductionForAgent": "Guide the user through adding preflight checks to their application. Preflights run before installation to verify the customer environment meets requirements. They're defined as Kubernetes Secrets in the Helm chart with Troubleshoot specs that check things like Kubernetes version, node resources, storage, and networking.",
        "contextForAgent": "Preflight checks use the Troubleshoot open source project. They're defined as Kubernetes Secrets with the label 'troubleshoot.sh/kind: preflight' in the Helm chart templates. Common checks include Kubernetes version, node CPU/memory, storage classes, and networking. The specs use collectors to gather data and analyzers to evaluate it.",
        "contentForUser": "# Task 7: Define Preflight Checks\n\nPreflight checks run before installation to ensure the customer environment meets your application's requirements. This prevents installation failures and provides clear guidance when requirements aren't met.\n\n## Common Preflight Checks\n- **Kubernetes Version**: Ensure compatible K8s version\n- **Node Resources**: Verify sufficient CPU, memory, storage\n- **Storage Classes**: Check for required storage providers  \n- **Networking**: Test connectivity and DNS resolution\n- **Permissions**: Validate RBAC and security policies\n\n## Benefits\n- **Prevent Failed Installations**: Catch issues before they cause problems\n- **Clear Error Messages**: Help users understand what's wrong\n- **Reduced Support**: Fewer \"it doesn't work\" tickets\n- **Better User Experience**: Guided environment validation",
        "operationsForAgent": "1. **Navigate to their Helm chart templates directory:**\n   ```bash\n   cd your-chart/templates\n   ```\n\n2. **Create a preflight checks Secret (preflight.yaml):**\n   ```yaml\n   apiVersion: v1\n   kind: Secret\n   metadata:\n     name: {{ include \"your-app.fullname\" . }}-preflight\n     labels:\n       troubleshoot.sh/kind: preflight\n   stringData:\n     preflight-spec: |\n       apiVersion: troubleshoot.sh/v1beta2\n       kind: Preflight\n       metadata:\n         name: {{ include \"your-app.fullname\" . }}\n       spec:\n         collectors: []\n         analyzers: []\n   ```\n\n3. **Add common preflight checks based on their application:**\n   \n   **Kubernetes Version Check:**\n   ```yaml\n   collectors:\n     - clusterVersion: {}\n   analyzers:\n     - clusterVersion:\n         outcomes:\n           - fail:\n               when: \"< 1.25.0\"\n               message: \"Kubernetes version 1.25.0 or higher is required\"\n           - pass:\n               message: \"Kubernetes version is supported\"\n   ```\n\n   **Node Resources Check:**\n   ```yaml\n   collectors:\n     - clusterResources: {}\n   analyzers:\n     - nodeResources:\n         checkName: Node CPU and Memory\n         outcomes:\n           - fail:\n               when: \"sum(cpuCapacity) < 4\"\n               message: \"Cluster must have at least 4 CPU cores available\"\n           - fail:\n               when: \"sum(memoryCapacity) < 8Gi\"\n               message: \"Cluster must have at least 8GB of memory available\"\n           - pass:\n               message: \"Cluster has sufficient CPU and memory\"\n   ```\n\n   **Storage Class Check:**\n   ```yaml\n   collectors:\n     - storageClass:\n         storageClassName: \"default\"\n   analyzers:\n     - storageClass:\n         checkName: Default Storage Class\n         storageClassName: \"default\"\n         outcomes:\n           - fail:\n               message: \"Default storage class is required\"\n           - pass:\n               message: \"Default storage class is available\"\n   ```\n\n4. **Package and test the changes:**\n   ```bash\n   cd .. # back to chart root\n   helm package -u .\n   mv *.tgz ../manifests/\n   cd ../manifests\n   replicated release create --yaml-dir . --promote Unstable\n   ```\n\n5. **Test preflight checks:**\n   - Install on a fresh VM with Embedded Cluster\n   - Preflights should run automatically before installation\n   - Verify they catch expected issues (test on undersized VM if possible)\n\n6. **Add more specific checks based on their application:**\n   - Database connectivity\n   - External API accessibility  \n   - Required ports availability\n   - Container registry access\n\n7. **Document what each check validates and how to resolve failures**"
      },
      "displayOrder": 8,
      "nextStepReference": 9
    },
    {
      "title": "Task 8: Add a Support Bundle Spec",
      "contentFields": {
        "version": "v1",
        "introductionForAgent": "Guide the user through adding support bundle collection to their application. Support bundles collect troubleshooting data from customer environments when issues occur. They should include logs, cluster info, and the same checks as preflights. This helps with customer support and issue diagnosis.",
        "contextForAgent": "Support bundles use Troubleshoot collectors and analyzers to gather diagnostic data. They're defined as Kubernetes Secrets with the label 'troubleshoot.sh/kind: support-bundle' in Helm templates. Common collectors include logs, cluster info, resources, and events. Best practice is to include all preflight checks plus additional troubleshooting data.",
        "contentForUser": "# Task 8: Add a Support Bundle Spec\n\nSupport bundles collect comprehensive troubleshooting data from customer environments. When users experience issues, they can generate a bundle that contains logs, configuration, and diagnostic information.\n\n## Support Bundle Contents\n- **Application Logs**: Pod logs, container outputs\n- **Cluster Information**: Node status, resource usage, events\n- **Configuration**: Helm values, secrets (redacted), config maps\n- **Network Information**: Services, ingress, connectivity tests\n- **All Preflight Checks**: Re-run environment validation\n\n## Benefits for Support Teams\n- **Complete Diagnostic Picture**: All necessary troubleshooting data\n- **Consistent Collection**: Same data format from all customers\n- **Privacy-Safe**: Automatic redaction of sensitive information\n- **Faster Resolution**: Less back-and-forth requesting information",
        "operationsForAgent": "1. **Create support bundle Secret in Helm templates (support-bundle.yaml):**\n   ```yaml\n   apiVersion: v1\n   kind: Secret\n   metadata:\n     name: {{ include \"your-app.fullname\" . }}-support-bundle\n     labels:\n       troubleshoot.sh/kind: support-bundle\n   stringData:\n     support-bundle-spec: |\n       apiVersion: troubleshoot.sh/v1beta2\n       kind: SupportBundle\n       metadata:\n         name: {{ include \"your-app.fullname\" . }}\n       spec:\n         collectors: []\n         analyzers: []\n   ```\n\n2. **Add essential collectors (start with logs):**\n   ```yaml\n   collectors:\n     # Collect application logs\n     - logs:\n         selector:\n           - app.kubernetes.io/name={{ include \"your-app.name\" . }}\n         namespace: {{ .Release.Namespace }}\n         limits:\n           maxAge: 720h  # 30 days\n           maxLines: 10000\n     \n     # Collect cluster information\n     - clusterInfo: {}\n     - clusterResources: {}\n   ```\n\n3. **Include all preflight checks in analyzers:**\n   - Copy all the analyzers from their preflight spec\n   - This ensures support bundles include environment validation\n   ```yaml\n   analyzers:\n     # Copy analyzers from preflight.yaml\n     - clusterVersion:\n         outcomes:\n           - fail:\n               when: \"< 1.25.0\"\n               message: \"Kubernetes version 1.25.0 or higher is required\"\n           # ... etc\n   ```\n\n4. **Add troubleshooting-specific collectors:**\n   ```yaml\n   collectors:\n     # Pod descriptions and events\n     - pods:\n         selector:\n           - app.kubernetes.io/name={{ include \"your-app.name\" . }}\n         namespace: {{ .Release.Namespace }}\n     \n     # Events from the namespace\n     - events:\n         namespace: {{ .Release.Namespace }}\n     \n     # ConfigMaps and Secrets (redacted)\n     - configMaps:\n         selector:\n           - app.kubernetes.io/name={{ include \"your-app.name\" . }}\n         namespace: {{ .Release.Namespace }}\n         includeAllData: false  # Redact sensitive data\n   ```\n\n5. **Add application-specific collectors based on their needs:**\n   ```yaml\n   # Database connectivity (if applicable)\n   - exec:\n       name: database-connectivity\n       selector:\n         - app.kubernetes.io/component=database\n       namespace: {{ .Release.Namespace }}\n       command: [\"pg_isready\"]\n       args: [\"-h\", \"localhost\"]\n   \n   # HTTP endpoint checks\n   - http:\n       name: api-health\n       get:\n         url: http://{{ include \"your-app.fullname\" . }}:8080/health\n   ```\n\n6. **Test the support bundle:**\n   ```bash\n   # Package and deploy\n   helm package -u .\n   mv *.tgz ../manifests/\n   cd ../manifests\n   replicated release create --yaml-dir . --promote Unstable\n   \n   # Test installation and bundle generation\n   # Follow: https://docs.replicated.com/vendor/support-bundle-generating\n   ```\n\n7. **Verify bundle contents:**\n   - Generate a support bundle from Admin Console\n   - Download and extract the .tar.gz file  \n   - Verify it contains expected logs and diagnostic data\n   - Check that sensitive information is properly redacted\n\n8. **Iterate and improve:**\n   - Add more collectors based on common support issues\n   - Include external dependency checks\n   - Add custom analyzers for known problem patterns"
      },
      "displayOrder": 9,
      "nextStepReference": 10
    },
    {
      "title": "Task 9: Alias Replicated Endpoints with Your Own Domains",
      "contentFields": {
        "version": "v1",
        "introductionForAgent": "Guide the user through setting up custom domains to alias Replicated endpoints. This provides better branding, simplifies security reviews, and gives customers a unified experience with the vendor's brand instead of seeing replicated.com URLs throughout the installation process.",
        "contextForAgent": "Custom domains allow vendors to alias Replicated endpoints like the Download Portal, Vendor Portal, and proxy registry with their own domain names. This requires DNS CNAME records and SSL certificate configuration. It's important for enterprise sales as customers often have security policies about external domains.",
        "contentForUser": "# Task 9: Alias Replicated Endpoints with Your Own Domains\n\nCustom domains provide a branded experience for your customers and simplify security reviews by consolidating external dependencies under your domain.\n\n## Replicated Endpoints to Alias\n- **Download Portal**: Where customers download installers (`downloads.yourcompany.com`)\n- **Vendor Portal**: Your team's management interface (`vendor.yourcompany.com`)\n- **Proxy Registry**: Container image proxy (`registry.yourcompany.com`)\n- **API Endpoints**: Various Replicated APIs\n\n## Benefits\n- **Brand Consistency**: Customers see your domain throughout\n- **Security Approval**: Easier to get corporate firewall approvals\n- **Professional Appearance**: No \"replicated.com\" in customer-facing URLs\n- **Simplified Reviews**: Single domain to evaluate vs multiple replicated endpoints\n\n## Requirements\n- Domain you control with DNS management access\n- Ability to create CNAME records\n- SSL certificate management (handled automatically)",
        "operationsForAgent": "1. **Plan your custom domain structure:**\n   Ask them what domains they'd like to use:\n   - Download Portal: `downloads.yourcompany.com` or `install.yourcompany.com`\n   - Vendor Portal: `vendor.yourcompany.com` or `admin.yourcompany.com`  \n   - Proxy Registry: `registry.yourcompany.com` or `images.yourcompany.com`\n\n2. **Access custom domains in Vendor Portal:**\n   - Go to https://vendor.replicated.com\n   - Navigate to Settings → Custom Domains\n   - Or follow: https://docs.replicated.com/vendor/custom-domains-using\n\n3. **Configure Download Portal domain:**\n   - Click \"Add Custom Domain\"\n   - Enter their chosen domain (e.g., `downloads.yourcompany.com`)\n   - Note the CNAME target provided by Replicated\n   - Create DNS CNAME record:\n     ```\n     downloads.yourcompany.com CNAME replicated-downloads-alias.com\n     ```\n\n4. **Configure Vendor Portal domain (if desired):**\n   - Add another custom domain for vendor portal access\n   - Follow same process with CNAME setup\n   - This allows their team to access vendor portal via branded URL\n\n5. **Configure Proxy Registry domain:**\n   - Add custom domain for proxy registry\n   - This affects how customers pull container images\n   - Update image references if necessary\n\n6. **Wait for SSL certificate provisioning:**\n   - Replicated automatically provisions SSL certificates\n   - Can take a few minutes to several hours for DNS propagation\n   - Monitor status in Vendor Portal\n\n7. **Test the custom domains:**\n   - Verify DNS resolution: `nslookup downloads.yourcompany.com`\n   - Test HTTPS access to each custom domain\n   - Ensure SSL certificates are valid\n\n8. **Update customer documentation:**\n   - Replace replicated.com URLs with custom domains\n   - Update installation instructions\n   - Inform existing customers of new download URLs\n\n9. **Validate with a test customer:**\n   - Create a test customer in Vendor Portal\n   - Verify they can access Download Portal via custom domain\n   - Test complete installation flow with branded URLs\n\n10. **Communicate changes to team:**\n    - Update internal documentation\n    - Inform sales team about custom domains for customer discussions\n    - Update marketing materials if they reference download URLs\n\nNote: Custom domains are typically an advanced/enterprise feature and may require specific Replicated plan levels."
      },
      "displayOrder": 10,
      "nextStepReference": 11
    },
    {
      "title": "Next Steps and Advanced Features",
      "contentFields": {
        "version": "v1",
        "introductionForAgent": "Congratulate the user on completing the core Replicated onboarding process. Provide guidance on advanced features they can explore next, additional installation methods, and ongoing optimization. Present this as the foundation for continued growth with Replicated Platform.",
        "contextForAgent": "The user has completed the 9 core onboarding tasks and now has a production-ready application distribution system. Advanced features include: Helm CLI installations, air-gap support, multi-node cluster configurations, license entitlements, backup/restore, custom metrics, CI/CD integration, and advanced channel management. These can be implemented incrementally based on customer needs.",
        "contentForUser": "# Congratulations! 🎉\n\nYou've successfully completed the Replicated Platform onboarding! Here's what you've accomplished:\n\n✅ **Created** a Replicated application with proper configuration\n✅ **Connected** your image registry for secure distribution\n✅ **Packaged** your Helm chart with the Replicated SDK\n✅ **Configured** initial release with Embedded Cluster support\n✅ **Customized** the Admin Console with branding and status monitoring\n✅ **Built** user-friendly configuration screens\n✅ **Added** preflight checks for environment validation\n✅ **Implemented** support bundle collection for troubleshooting\n✅ **Set up** custom domains for professional branding\n\n## Your Application is Now Ready For\n- **Enterprise customers** with Embedded Cluster installations\n- **Existing Kubernetes clusters** with KOTS installations  \n- **Production deployments** with proper monitoring and support\n- **Customer onboarding** with guided configuration\n\n## What to Explore Next",
        "operationsForAgent": "1. **Celebrate their accomplishment!**\n   - Acknowledge the significant work they've completed\n   - Highlight that they now have a production-ready distribution system\n\n2. **Suggest immediate next steps based on their needs:**\n\n   **For Development Teams:**\n   - **Helm CLI Support**: Enable native Helm installations\n     - Guide: https://docs.replicated.com/vendor/helm-image-registry\n     - Benefit: Developer-friendly installation method\n   \n   **For Enterprise Sales:**\n   - **Air-gap Installation Support**: For customers without internet access\n     - Guide: https://docs.replicated.com/vendor/operator-defining-additional-images\n     - Critical for government and high-security customers\n   \n   **For Customer Success:**\n   - **Backup and Restore**: Disaster recovery capabilities\n     - Embedded Cluster: https://docs.replicated.com/vendor/embedded-disaster-recovery\n     - KOTS: https://docs.replicated.com/vendor/snapshots-configuring-backups\n\n3. **Intermediate features to consider:**\n   - **License Entitlements**: Custom license fields for feature gating\n   - **Custom Metrics**: Application-specific telemetry and insights\n   - **Application Links**: Quick access buttons in Admin Console\n   - **Multi-node Cluster Roles**: For Embedded Cluster scalability\n\n4. **Advanced operational features:**\n   - **CI/CD Integration**: Automate release creation and promotion\n     - Guide: https://docs.replicated.com/vendor/ci-overview\n   - **Compatibility Matrix**: Automated testing across Kubernetes versions\n     - Guide: https://docs.replicated.com/vendor/testing-about\n   - **Advanced Channel Management**: Custom release channels for different customer segments\n\n5. **Provide specific recommendations based on their situation:**\n   - Ask about their typical customer deployment scenarios\n   - Understand their support challenges\n   - Identify their next biggest pain points\n\n6. **Resources for continued learning:**\n   - Replicated Documentation: https://docs.replicated.com\n   - Community Forum: https://community.replicated.com\n   - Best Practices Guide: For writing great on-prem documentation\n\n7. **Immediate action items:**\n   - Update their customer-facing documentation\n   - Test the complete flow with a pilot customer\n   - Plan rollout strategy for existing customers\n   - Schedule team training on Admin Console features\n\n8. **Ask about their experience:**\n   - What was most challenging during onboarding?\n   - Which features do they think will provide the most value?\n   - Are there specific customer scenarios they want to address next?\n\n9. **Offer continued support:**\n   - Remind them about Replicated community resources\n   - Suggest scheduling follow-up sessions for advanced features\n   - Encourage them to start with small pilot deployments"
      },
      "displayOrder": 11,
      "nextStepReference": null
    }
  ]
}