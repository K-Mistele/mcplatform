{
  "version": "1.0",
  "exportedAt": "2025-08-05T22:14:39.270Z",
  "walkthrough": {
    "title": "Replicated Platform Quick Start",
    "description": "A comprehensive quick start guide to help new users learn about the Replicated Platform. Complete this walkthrough to understand how to create, install, and update releases for applications using Replicated.",
    "type": "quickstart",
    "status": "published",
    "createdAt": 1754350509258,
    "updatedAt": 1754350509258,
    "estimatedDurationMinutes": 45,
    "tags": [
      "replicated",
      "quickstart",
      "helm",
      "embedded-cluster",
      "kots"
    ],
    "metadata": {
      "createdFor": "Replicated demo",
      "importedAt": "2025-08-04T23:35:09.258Z",
      "importedFrom": "replicated-quickstart-demo",
      "sourceDocument": "specifications/demos/replicated/quick-start-merged.mdx"
    }
  },
  "steps": [
    {
      "title": "Environment Setup and Requirements",
      "contentFields": {
        "version": "v1",
        "contentForUser": "# Environment Setup and Requirements\n\nWelcome to the Replicated Platform quick start! You'll be working on your local machine to prepare everything, then deploy to a Linux VM at the end.\n\n**What you'll need:**\n- Your local development machine (where you are now)\n- A Linux VM that meets these requirements:\n  - Linux OS with x86-64 architecture\n  - systemd\n  - At least 2GB RAM and 2 CPU cores\n  - 40Gi+ available storage in `/var/lib/embedded-cluster`\n  - Network access to replicated.app and proxy.replicated.com\n\nI'll create a verification script you can run on your VM to check these requirements.",
        "contextForAgent": "The user is working on their local machine throughout most of this walkthrough. They'll need a Linux VM ready for the deployment step later. Embedded Cluster requires specific system specifications. Rather than running commands directly, create a shell script the user can save and run on their VM when ready.",
        "operationsForAgent": "1. Create a file named `check-vm-requirements.sh` with a shell script that verifies all \n  requirements:\n\n```sh\n#!/bin/bash\n\n# Replicated Embedded Cluster VM Requirements Checker\n# Run this script on your Linux VM to verify it meets the requirements\n\necho \"ðŸ” Checking Replicated Embedded Cluster VM Requirements...\"\necho \"================================================================\"\n\nPASS_COUNT=0\nTOTAL_CHECKS=7\nFAILED_CHECKS=()\n\n# Color codes for output\nGREEN='\\033[0;32m'\nRED='\\033[0;31m'\nYELLOW='\\033[1;33m'\nNC='\\033[0m' # No Color\n\ncheck_passed() {\n    echo -e \"${GREEN}âœ“ PASS${NC}: $1\"\n    ((PASS_COUNT++))\n}\n\ncheck_failed() {\n    echo -e \"${RED}âœ— FAIL${NC}: $1\"\n    FAILED_CHECKS+=(\"$1\")\n}\n\ncheck_warning() {\n    echo -e \"${YELLOW}âš  WARNING${NC}: $1\"\n}\n\necho \"1. Checking Operating System and Architecture...\"\nif [[ \"$OSTYPE\" == \"linux-gnu\"* ]]; then\n    ARCH=$(uname -m)\n    if [[ \"$ARCH\" == \"x86_64\" ]]; then\n        check_passed \"Linux x86-64 architecture detected\"\n    else\n        check_failed \"Architecture is $ARCH, but x86-64 is required\"\n    fi\nelse\n    check_failed \"Not running on Linux (detected: $OSTYPE)\"\nfi\n\necho \"\"\necho \"2. Checking systemd...\"\nif command -v systemctl &> /dev/null && systemctl --version &> /dev/null; then\n    check_passed \"systemd is available\"\nelse\n    check_failed \"systemd is not available or not working\"\nfi\n\necho \"\"\necho \"3. Checking CPU cores...\"\nCPU_CORES=$(nproc)\nif [[ $CPU_CORES -ge 2 ]]; then\n    check_passed \"CPU cores: $CPU_CORES (minimum 2 required)\"\nelse\n    check_failed \"CPU cores: $CPU_CORES (minimum 2 required)\"\nfi\n\necho \"\"\necho \"4. Checking memory...\"\nMEMORY_GB=$(free -g | awk '/^Mem:/{print $2}')\nif [[ $MEMORY_GB -ge 2 ]]; then\n    check_passed \"Memory: ${MEMORY_GB}GB (minimum 2GB required)\"\nelse\n    check_failed \"Memory: ${MEMORY_GB}GB (minimum 2GB required)\"\nfi\n\necho \"\"\necho \"5. Checking disk space for /var/lib/embedded-cluster...\"\nTARGET_DIR=\"/var/lib/embedded-cluster\"\nPARENT_DIR=\"/var/lib\"\n\n# Check if the target directory exists, if not check parent directory\nif [[ -d \"$TARGET_DIR\" ]]; then\n    AVAILABLE_SPACE=$(df -BG \"$TARGET_DIR\" | tail -1 | awk '{print $4}' | sed 's/G//')\n    SPACE_LOCATION=\"$TARGET_DIR\"\nelif [[ -d \"$PARENT_DIR\" ]]; then\n    AVAILABLE_SPACE=$(df -BG \"$PARENT_DIR\" | tail -1 | awk '{print $4}' | sed 's/G//')\n    SPACE_LOCATION=\"$PARENT_DIR (parent of target directory)\"\nelse\n    AVAILABLE_SPACE=$(df -BG / | tail -1 | awk '{print $4}' | sed 's/G//')\n    SPACE_LOCATION=\"/ (root filesystem)\"\nfi\n\nif [[ $AVAILABLE_SPACE -ge 40 ]]; then\n    check_passed \"Available disk space: ${AVAILABLE_SPACE}GB in $SPACE_LOCATION (minimum 40GB required)\"\nelse\n    check_failed \"Available disk space: ${AVAILABLE_SPACE}GB in $SPACE_LOCATION (minimum 40GB required)\"\nfi\n\necho \"\"\necho \"6. Checking network connectivity...\"\nif curl -s --connect-timeout 10 https://replicated.app > /dev/null; then\n    check_passed \"Can reach replicated.app\"\nelse\n    check_failed \"Cannot reach replicated.app (required for installation)\"\nfi\n\nif curl -s --connect-timeout 10 https://proxy.replicated.com > /dev/null; then\n    check_passed \"Can reach proxy.replicated.com\"\nelse\n    check_failed \"Cannot reach proxy.replicated.com (required for installation)\"\nfi\n\n# Summary\necho \"\"\necho \"================================================================\"\necho \"ðŸ“Š SUMMARY\"\necho \"================================================================\"\n\nif [[ $PASS_COUNT -eq $TOTAL_CHECKS ]]; then\n    echo -e \"${GREEN}ðŸŽ‰ SUCCESS!${NC} Your VM meets all requirements for Replicated Embedded Cluster\"\n    echo \"\"\n    echo \"You're ready to proceed with the Embedded Cluster installation!\"\nelif [[ $PASS_COUNT -ge 4 ]] && [[ ${#FAILED_CHECKS[@]} -gt 0 ]]; then\n    echo -e \"${YELLOW}âš ï¸  MOSTLY READY${NC} - $PASS_COUNT/$TOTAL_CHECKS checks passed\"\n    echo \"\"\n    echo \"Failed checks that need attention:\"\n    for failed in \"${FAILED_CHECKS[@]}\"; do\n        echo \"  â€¢ $failed\"\n    done\n    echo \"\"\n    echo \"Please address the failed requirements before proceeding.\"\nelse\n    echo -e \"${RED}âŒ NOT READY${NC} - Only $PASS_COUNT/$TOTAL_CHECKS checks passed\"\n    echo \"\"\n    if [[ ${#FAILED_CHECKS[@]} -gt 0 ]]; then\n        echo \"Failed checks that need attention:\"\n        for failed in \"${FAILED_CHECKS[@]}\"; do\n            echo \"  â€¢ $failed\"\n        done\n        echo \"\"\n    fi\n    echo \"Please address the failed requirements before proceeding.\"\nfi\n\necho \"\"\necho \"For more information about Embedded Cluster requirements, visit:\"\necho \"https://docs.replicated.com/enterprise/installing-embedded-requirements\"\n```\n\n2. The script should check: OS/architecture, systemd, CPU/memory, disk space, and network connectivity per the listed specifications\n3. Make the script user-friendly with clear output about what passes/fails\n4. Tell the user to save this script and run it on their Linux VM when they're ready to verify requirements\n5. Explain they can proceed with the walkthrough on their local machine while their VM is being prepared",
        "introductionForAgent": "This step ensures the user understands the VM requirements for Embedded Cluster. Since the user is \n  working on their local machine, create a verification script they can run on their Linux VM later to check prerequisites."
      },
      "displayOrder": 0,
      "createdAt": 1754350510386,
      "updatedAt": 1754350510386,
      "metadata": {},
      "nextStepReference": 1
    },
    {
      "title": "Create Vendor Portal Account and Install CLI",
      "contentFields": {
        "version": "v1",
        "contentForUser": "# Setting Up Your Replicated Account\n\nLet's get you started with the Replicated Platform by creating your account and installing the necessary tools.\n\n1. **Create a Vendor Portal account** at https://vendor.replicated.com\n   - You can create a new team or join an existing one\n\n2. **Install the Replicated CLI** on your local machine\n\nThe CLI will allow you to create applications, manage releases, and interact with the Replicated Platform.",
        "contextForAgent": "The Vendor Portal is the web interface for managing Replicated applications. The Replicated CLI allows developers to interact with the platform from the command line. The CLI can be installed via Homebrew on macOS or downloaded directly for other platforms.",
        "operationsForAgent": "1. Guide the user to create an account at https://vendor.replicated.com\n2. Once they have an account, install the Replicated CLI:\n   - For macOS: Run `brew install replicatedhq/replicated/cli`\n   - For other platforms, refer to https://docs.replicated.com/reference/replicated-cli-installing\n3. Verify installation: `replicated version`\n4. Authorize the CLI: `replicated login`\n5. Help the user complete the browser-based authentication flow",
        "introductionForAgent": "This step guides the user through creating a Vendor Portal account and installing the Replicated CLI on their local machine. The CLI is essential for creating and managing applications."
      },
      "displayOrder": 1,
      "createdAt": 1754350510302,
      "updatedAt": 1754350510302,
      "metadata": {},
      "nextStepReference": 2
    },
    {
      "title": "Create Your First Application",
      "contentFields": {
        "version": "v1",
        "contentForUser": "# Creating Your First Application\n\nNow let's create your first application on the Replicated Platform. We'll create an application called 'Gitea' which is a self-hosted Git service.\n\nAfter creating the application, we'll set up an environment variable to make working with the CLI easier and save it for future use.",
        "contextForAgent": "When creating an application, Replicated generates a unique slug (like 'gitea-kite'). This slug is used to identify the application in all CLI commands. Setting the REPLICATED_APP environment variable eliminates the need to use --app flag with every command. The .env.replicated file ensures the variable persists across sessions and can be re-imported later. We use .env.replicated instead of .env to avoid permission issues that agents often encounter.",
        "operationsForAgent": "1. Create the application: `replicated app create Gitea`\n2. Note the APP_SLUG from the output (e.g., 'gitea-kite')\n3. Set the environment variable: `export REPLICATED_APP=APP_SLUG`\n   - Replace APP_SLUG with the actual slug from step 2\n4. APPEND the environment variable to a .env.replicated file for persistence:\n   - Use: `echo \"REPLICATED_APP=APP_SLUG\" >> .env.replicated`\n   - Make sure to use >> (append) not > (overwrite)\n   - Replace APP_SLUG with the actual slug\n5. Verify the app was created: `replicated app ls`\n6. Explain that this environment variable allows omitting the --app flag in future commands\n7. Mention that the .env.replicated file will be used to restore this variable in future sessions",
        "introductionForAgent": "This step creates a new application called 'Gitea' using the Replicated CLI. The user will also set up an environment variable to make subsequent CLI commands easier. The environment variable must be saved to a .env.replicated file for persistence."
      },
      "displayOrder": 2,
      "createdAt": 1754350510216,
      "updatedAt": 1754350510216,
      "metadata": {},
      "nextStepReference": 3
    },
    {
      "title": "Prepare the Gitea Helm Chart",
      "contentFields": {
        "version": "v1",
        "contentForUser": "# Preparing the Gitea Helm Chart\n\nLet's download the Bitnami Gitea Helm chart and integrate it with the Replicated SDK. The SDK enables features like:\n- Instance telemetry\n- Support bundle collection\n- License enforcement\n- Update notifications\n\nWe'll pull version 1.0.6 of the Gitea chart and add the Replicated SDK as a dependency.",
        "contextForAgent": "The Replicated SDK is a Helm chart that provides access to Replicated features like telemetry, instance insights, and support bundle collection. It's added as a dependency in the Chart.yaml file. The chart is then packaged into a .tgz archive for distribution.",
        "operationsForAgent": "1. Pull the Gitea Helm chart: `helm pull --untar oci://registry-1.docker.io/bitnamicharts/gitea --version 1.0.6`\n2. Change to the gitea directory: `cd gitea`\n3. Edit Chart.yaml and add the Replicated SDK dependency:\n```yaml\n# Chart.yaml\ndependencies:\n- name: replicated\n  repository: oci://registry.replicated.com/library\n  version: 1.7.0\n```\n4. Update dependencies and package: `helm package -u .`\n5. Verify the .tgz file was created: `ls -la gitea-1.0.6.tgz`",
        "introductionForAgent": "This step downloads the Bitnami Gitea Helm chart and adds the Replicated SDK as a dependency. This is a crucial step that integrates Replicated features into the application."
      },
      "displayOrder": 3,
      "createdAt": 1754350510126,
      "updatedAt": 1754350612363,
      "metadata": {},
      "nextStepReference": 4
    },
    {
      "title": "Create Manifest Files",
      "contentFields": {
        "version": "v1",
        "contentForUser": "# Creating Manifest Files\n\nNow we'll create the YAML files that tell Replicated how to deploy and manage your application. These files enable features like:\n\n- **HelmChart CR**: Instructions for deploying the Helm chart\nThe KOTS HelmChart custom resource provides instructions to KOTS about how to deploy the Helm chart. The name and chartVersion listed in the HelmChart custom resource must match the name and version of a Helm chart archive in the release. The optionalValues field sets the specified Helm values when a given conditional statement evaluates to true. In this case, if the application is installed with Embedded Cluster, then the Gitea service type is set to NodePort and the node port is set to \"32000\". This will allow Gitea to be accessed from the local machine after deployment for the purpose of this quick start.\n\n\n- **Application CR**: Admin Console branding and status monitoring\nThe KOTS Application custom resource enables features in the Replicated Admin Console such as branding, release notes, application status indicators, and custom graphs.\n\nThe YAML below provides a name for the application to display in the Admin Console, adds a custom status informer that displays the status of the gitea Deployment resource in the Admin Console dashboard, adds a custom application icon, and adds the port where the Gitea service can be accessed so that the user can open the application after installation.\n\n- **SIG Application CR**: UI elements like the \"Open App\" button\nThe Kubernetes SIG Application custom resource supports functionality such as including buttons and links on the Replicated Admin Console dashboard. The YAML below adds an Open App button to the Admin Console dashboard that opens the application using the service port defined in the KOTS Application custom resource.\n\n- **Embedded Cluster Config**: Cluster configuration settings\nTo install your application with Embedded Cluster, an Embedded Cluster Config must be present in the release. At minimum, the Embedded Cluster Config sets the version of Embedded Cluster that will be installed. You can also define several characteristics about the cluster.\n\nLet's create these files in a manifests directory.",
        "contextForAgent": "The manifest files include: gitea.yaml (HelmChart CR for deployment instructions), kots-app.yaml (Application CR for Admin Console features), k8s-app.yaml (SIG Application CR for UI elements), and embedded-cluster.yaml (Config for Embedded Cluster version). These files must be in a 'manifests' directory along with the Helm chart .tgz file.",
        "operationsForAgent": "1. Create manifests directory: `mkdir manifests`\n2. Move the Helm chart: `mv gitea-1.0.6.tgz manifests`\n3. Change to manifests: `cd manifests`\n4. Create the files: `touch gitea.yaml kots-app.yaml k8s-app.yaml embedded-cluster.yaml`\n5. Add the gitea.yaml content (HelmChart CR with NodePort configuration):\n```yaml\napiVersion: kots.io/v1beta2\nkind: HelmChart\nmetadata:\n  name: gitea\nspec:\n  # chart identifies a matching chart from a .tgz\n  chart:\n    name: gitea\n    chartVersion: 1.0.6\n  optionalValues:\n  - when: 'repl{{ eq Distribution \"embedded-cluster\" }}'\n    recursiveMerge: false\n    values:\n      service:\n        type: NodePort\n        nodePorts:\n          http: \"32000\"\n```\n6. Add the kots-app.yaml content (Application CR with status informers and ports):\n```yaml\napiVersion: kots.io/v1beta1\nkind: Application\nmetadata:\n  name: gitea\nspec:\n  title: Gitea\n  statusInformers:\n    - deployment/gitea\n  ports:\n    - serviceName: \"gitea\"\n      servicePort: 3000\n      localPort: 32000\n      applicationUrl: \"http://gitea\"\n  icon: https://raw.githubusercontent.com/cncf/artwork/master/projects/kubernetes/icon/color/kubernetes-icon-color.png\n```\n7. Add the k8s-app.yaml content (SIG Application CR with Open App link):\n```yaml\napiVersion: app.k8s.io/v1beta1\nkind: Application\nmetadata:\n  name: \"gitea\"\nspec:\n  descriptor:\n    links:\n      - description: Open App\n        # needs to match applicationUrl in kots-app.yaml\n        url: \"http://gitea\"\n```\n8. Add the embedded-cluster.yaml content (Config with version 2.6.0+k8s-1.30):\n```yaml\napiVersion: embeddedcluster.replicated.com/v1beta1\nkind: Config\nspec:\n  version: 2.6.0+k8s-1.30\n```\n9. Verify all files are created: `ls -la`",
        "introductionForAgent": "This step creates the necessary YAML manifest files that configure how the application is deployed with KOTS and Embedded Cluster. Each file serves a specific purpose in the Replicated Platform."
      },
      "displayOrder": 4,
      "createdAt": 1754350510040,
      "updatedAt": 1754350510040,
      "metadata": {},
      "nextStepReference": 5
    },
    {
      "title": "Lint and Create First Release",
      "contentFields": {
        "version": "v1",
        "contentForUser": "# Creating Your First Release\n\nBefore creating a release, let's validate our YAML files using the Replicated linter. This helps catch common issues early.\n\nAfter validation, we'll create the release and promote it to the Unstable channel, making it available for installation.\n\n**Note**: You can ignore warnings about missing config, preflight, and troubleshoot specs for this quick start.",
        "contextForAgent": "The linter checks for common issues and best practices. Warning messages about missing specs (config, preflight, troubleshoot) can be ignored for this quick start. The release create command packages all manifests and promotes to the specified channel in one operation.",
        "operationsForAgent": "1. Run the linter: `replicated release lint --yaml-dir .`\n2. Review the output - warnings about missing specs are OK\n3. Create and promote the release: `replicated release create --yaml-dir . --promote Unstable`\n4. Note the sequence number (should be 1) and channel ID\n5. Verify the release: `replicated release ls`\n6. Explain that the release is now available in the Unstable channel",
        "introductionForAgent": "This step validates the YAML files using the linter and creates the first release, promoting it to the Unstable channel. This makes the application available for installation."
      },
      "displayOrder": 5,
      "createdAt": 1754350509954,
      "updatedAt": 1754350509954,
      "metadata": {},
      "nextStepReference": 6
    },
    {
      "title": "Create a Customer",
      "contentFields": {
        "version": "v1",
        "contentForUser": "# Creating a Customer\n\nIn Replicated, customers represent the organizations that install your application. Each customer gets a license that controls:\n- Which channels they can access\n- What features are enabled\n- Installation methods available\n\nLet's create a test customer with access to install via Embedded Cluster.",
        "contextForAgent": "In the Vendor Portal, customers need specific entitlements enabled: KOTS Install Enabled and Embedded Cluster Enabled. The Development license type is appropriate for testing. The customer is assigned to the Unstable channel to access releases promoted there.",
        "operationsForAgent": "Direct the user to complete the following actions:\n1. navigate to the vendor portal: https://vendor.replicated.com\n2. Select the Gitea application from the dropdown\n3. Navigate to Customers > Create customer\n4. Fill in the form:\n   - Customer name: 'Example Customer' or similar\n   - Channel: Unstable\n   - License type: Development\n   - Enable: KOTS Install Enabled\n   - Enable: Embedded Cluster Enabled\n5. Click Save Changes\n6. Explain that this customer can now install releases from the Unstable channel\n\nAsk the user to complete these actions. Once they have confirmed that they created the user, you can confirm they did so by running `replicated customer ls`.",
        "introductionForAgent": "This step creates a customer in the Vendor Portal with appropriate entitlements. Customers represent organizations that install your application, and licenses control their access and features."
      },
      "displayOrder": 6,
      "createdAt": 1754350509867,
      "updatedAt": 1754350509867,
      "metadata": {},
      "nextStepReference": 7
    },
    {
      "title": "Install with Embedded Cluster",
      "contentFields": {
        "version": "v1",
        "contentForUser": "# Installing with Embedded Cluster\n\nNow let's install your application on the VM using Embedded Cluster. This will:\n1. Provision a Kubernetes cluster\n2. Install the Replicated Admin Console\n3. Prepare for application deployment\n\nThe installation commands are unique to each customer and include their license.",
        "contextForAgent": "Embedded Cluster provides a complete Kubernetes distribution with the application. The install instructions are unique per customer and include the license. The installation provisions the cluster and deploys the Admin Console, but not the application itself yet. Installation typically takes several minutes.",
        "operationsForAgent": "Direct the user to complete the following actions:\n1. On the customer page, click 'Install instructions > Embedded Cluster'\n2. SSH into the VM\n3. Run the curl command to download the installer\n4. Run the tar command to extract files\n5. Run the install command (e.g., `sudo ./APP_SLUG install --license LICENSE_FILE`)\n6. When prompted, create an Admin Console password (min 6 characters)\n7. Wait for installation to complete (look for success messages)\n\nOnce you have directed the user to do this, ask them to please wait until the installation completes, and then copy/paste in the admin console URL from the output when they are ready to continue.\n\nThen, onExplain that the cluster is ready but the app isn't deployed yet",
        "introductionForAgent": "This step guides the user through installing the application on their VM using Embedded Cluster. This includes downloading the installer, running it, and setting up the Admin Console password."
      },
      "displayOrder": 7,
      "createdAt": 1754350509780,
      "updatedAt": 1754350735575,
      "metadata": {},
      "nextStepReference": 8
    },
    {
      "title": "Configure and Deploy Application",
      "contentFields": {
        "version": "v1",
        "contentForUser": "# Configuring and Deploying Your Application\n\nWith the Admin Console installed, let's complete the setup and deploy your Gitea application.\n\nYou'll:\n1. Secure the Admin Console connection\n2. Review cluster configuration\n3. Deploy the application\n4. Access the running Gitea instance\n\nThe application will be accessible once its status shows as 'Ready'.",
        "contextForAgent": "The Admin Console uses self-signed certificates by default, causing browser warnings. The setup includes certificate configuration and cluster verification. After setup, the application is deployed from the dashboard. Status changes from Missing to Unavailable to Ready as pods are created.",
        "operationsForAgent": "1. Navigate to the Admin Console URL in a browser\n2. Click 'Start' on the landing page\n3. On 'Secure the Admin Console', click Continue and bypass browser warnings\n4. On 'Certificate type', choose Self-signed or upload custom certs\n5. Log in with the password created during installation\n6. On 'Configure the cluster', review node info and click Continue\n7. On the dashboard, click 'Deploy' next to the version\n8. Confirm by clicking 'Yes, Deploy'\n9. Monitor status (Missing â†’ Unavailable â†’ Ready)\n10. Once Ready, click 'Open App' to access Gitea\n11. Verify Gitea loads successfully\n\nTell them they may have to access the app directly _without_ a DNS name using the IP address of the host, and that they should check port 32000. If they are unable to reach it, make sure that their firewall isn't blocking it (common for AWS ECSs and similar cloud instances that often only expose port 22 by default.",
        "introductionForAgent": "This step walks through the Admin Console setup wizard and deploys the application. The user will configure security settings and deploy the Gitea application."
      },
      "displayOrder": 8,
      "createdAt": 1754350509694,
      "updatedAt": 1754350834658,
      "metadata": {},
      "nextStepReference": 9
    },
    {
      "title": "Verify Instance Telemetry",
      "contentFields": {
        "version": "v1",
        "contentForUser": "# Viewing Instance Telemetry\n\nReplicated automatically collects telemetry from installed instances, giving you visibility into:\n- Active installations\n- Kubernetes versions in use\n- Application versions deployed\n- Instance health status\n\nLet's check that your instance is reporting telemetry correctly.",
        "contextForAgent": "Instance telemetry is automatically collected by KOTS and the Replicated SDK. It includes information about the cluster, Kubernetes version, SDK version, and application status. This data appears in the Vendor Portal under the customer record.",
        "operationsForAgent": "1. Return to the Vendor Portal\n2. Navigate to Customers\n3. Find your customer and verify an active instance is shown\n4. Click on the Instance ID to view details\n5. Show the instance information including:\n   - Kubernetes version\n   - Replicated SDK version\n   - Last check-in time\n   - Application status\n6. Explain how this telemetry helps understand customer deployments",
        "introductionForAgent": "This step shows how to view instance telemetry in the Vendor Portal. This data helps vendors understand their customer deployments and usage patterns."
      },
      "displayOrder": 9,
      "createdAt": 1754350509609,
      "updatedAt": 1754350509609,
      "metadata": {},
      "nextStepReference": 10
    },
    {
      "title": "Add Preflight Checks",
      "contentFields": {
        "version": "v1",
        "contentForUser": "# Adding Preflight Checks\n\nPreflight checks validate the installation environment before deploying or updating your application. They can check:\n- System requirements\n- Network connectivity\n- Required services\n- Security policies\n\nLet's add a simple preflight check that verifies internet connectivity by testing access to the Slack API.",
        "contextForAgent": "Preflight checks use the Troubleshoot framework to validate environments. They're defined in a Secret with the troubleshoot.sh/kind: preflight label. The example checks Slack API accessibility. The Helm chart version must be incremented and the HelmChart CR updated to match.",
        "operationsForAgent": "1. Go to the gitea directory on local machine\n2. Create preflight file: `touch templates/gitea-preflights.yaml`\n3. Add the preflight Secret YAML with HTTP check for Slack API:\n```yaml\napiVersion: v1\nkind: Secret\nmetadata:\n  labels:\n    troubleshoot.sh/kind: preflight\n  name: \"{{ .Release.Name }}-preflight-config\"\nstringData:\n  preflight.yaml: |\n    apiVersion: troubleshoot.sh/v1beta2\n    kind: Preflight\n    metadata:\n      name: preflight-sample\n    spec:\n      collectors:\n        - http:\n            collectorName: slack\n            get:\n              url: https://api.slack.com/methods/api.test\n      analyzers:\n        - textAnalyze:\n            checkName: Slack Accessible\n            fileName: slack.json\n            regex: '\"status\": 200,'\n            outcomes:\n              - pass:\n                  when: \"true\"\n                  message: \"Can access the Slack API\"\n              - fail:\n                  when: \"false\"\n                  message: \"Cannot access the Slack API. Check that the server can reach the internet and check [status.slack.com](https://status.slack.com).\"\n```\n4. Update Chart.yaml version to 1.0.7\n5. Package the chart: `helm package -u .`\n6. Move to manifests: `mv gitea-1.0.7.tgz manifests`\n7. Update manifests/gitea.yaml chartVersion to 1.0.7\n8. Remove old chart: `rm manifests/gitea-1.0.6.tgz`\n9. Create new release: `replicated release create --yaml-dir manifests --promote Unstable --version 0.0.2`\n10. Note the sequence number (should be 2)",
        "introductionForAgent": "This step creates a new release that adds preflight checks to the application. Preflight checks validate the environment before deployment or updates."
      },
      "displayOrder": 10,
      "createdAt": 1754350509520,
      "updatedAt": 1754350509520,
      "metadata": {},
      "nextStepReference": 11
    },
    {
      "title": "Update Application",
      "contentFields": {
        "version": "v1",
        "contentForUser": "# Updating Your Application\n\nOne of Replicated's key features is seamless application updates. The Admin Console automatically detects new versions and guides users through the update process.\n\nLet's update to the new version with preflight checks and see how the update workflow works.",
        "contextForAgent": "Updates appear automatically in the Version History tab. The Embedded Cluster upgrade wizard guides through the update process, including preflight checks, configuration review, and deployment. The preflight check added in the previous step will run during the update.",
        "operationsForAgent": "1. In the Admin Console, go to 'Version history' tab\n2. Verify the new version (0.0.2) appears\n3. Click 'Deploy' next to the new version\n4. The Embedded Cluster upgrade wizard opens\n5. On 'Preflight checks', verify 'Slack Accessible' passes\n6. Click 'Next: Confirm and deploy'\n7. Note that Config screen is skipped (no Config CR in this release)\n8. On 'Confirm and Deploy', click 'Deploy'\n9. Monitor the update progress\n10. Verify the application is running the new version",
        "introductionForAgent": "This final step demonstrates updating an installed application to a new version through the Admin Console. The update process includes running the new preflight checks."
      },
      "displayOrder": 11,
      "createdAt": 1754350509433,
      "updatedAt": 1754350509433,
      "metadata": {},
      "nextStepReference": 12
    },
    {
      "title": "Clean Up and Next Steps",
      "contentFields": {
        "version": "v1",
        "contentForUser": "# Congratulations! ðŸŽ‰\n\nYou've successfully completed the Replicated quick start! You've learned how to:\n- Add the Replicated SDK to a Helm chart\n- Create and promote releases\n- Install with Embedded Cluster\n- View instance telemetry\n- Add preflight checks\n- Update applications\n\nLet's clean up the test installation and discuss next steps for onboarding your own application.",
        "contextForAgent": "The reset command removes the Embedded Cluster installation from the VM. After reset, the VM should be rebooted. The user has now completed the quick start and understands the basic workflow of creating, installing, and updating releases.",
        "operationsForAgent": "Direct the user to complete the following actions:\n1. SSH into the VM\n2. Run reset command: `sudo ./APP_SLUG reset`\n   - Replace APP_SLUG with the actual application slug\n3. Confirm the reset when prompted\n4. Reboot the VM: `sudo reboot`\n\nThen:\n5. Provide next steps:\n   - Review 'Onboard to the Replicated Platform' documentation\n   - Explore additional features like Config, Support Bundles, and air-gapped installations\n   - Consider multi-node clusters and high availability\n   - Learn about license entitlements and custom metrics\n6. Share key documentation links\n7. Ask the user if they have any feedback. Indicate that we really value feedback, both positive and negative. IF the user provides feedback, go ahead and submit it via the support tool with the title [FEEDBACK]: <brief summary of feedback>.",
        "introductionForAgent": "This step helps the user clean up their test installation and provides guidance on next steps for onboarding their own application."
      },
      "displayOrder": 12,
      "createdAt": 1754350509344,
      "updatedAt": 1754419762196,
      "metadata": {},
      "nextStepReference": null
    }
  ],
  "metadata": {
    "originalId": "wt_gw6JrtdVzy3lfSvbdtRVT",
    "originalOrganizationId": "1HBRrQgQ2oBucPpcNY8K08T0QC2QTW5F",
    "stepCount": 13,
    "serverAssociationCount": 1
  }
}